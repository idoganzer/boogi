{"componentChunkName":"component---src-templates-docs-js","path":"/55mFFps3KWvaLGbzPt9M","result":{"data":{"site":{"siteMetadata":{"title":"My BooGi App","docsLocation":"","docsLocationType":"","editable":true}},"mdx":{"fields":{"id":"2f2ae413-aa4a-5ac3-8344-26df686f036b","title":"Upgrade Files","slug":"/55mFFps3KWvaLGbzPt9M"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Upgrade Files\",\n  \"editable\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"div\", {\n    align: \"center\",\n    style: {\n      \"backgroundColor\": \"#e5ecff\"\n    }\n  }, \"    \", mdx(\"br\", null), \"    \", mdx(\"div\", null, \"DOC\"), \"    \", mdx(\"h1\", null, \"Upgrade Files\"), \"    \", mdx(\"br\", null), \"  \"), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Files Used:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"\\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"\\uD83D\\uDCC4 src/swimmagic/autofix.ts\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"\\uD83D\\uDCC4 src/shared/common.ts\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In this Swimm we will talk about the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"upgrade-files\"), \" command and how we deal with backwards computability when updating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\"), \" file structure.\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The command is a maintenance command that was created while making a major change in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\"), \" files structures (and in autosync). In order to overcome performance issue related to the SWM changes, we wanted to have a way to update the files in a dedicated operation that will run once and update the files for the users. The other way to update a file is for to edit and save the unit, for each unit in the repo.\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The command can be run for a specific unitId or for all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\"), \" in the repository\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 12     import { gitAddFile } from 'Shared/gitwrapper';\\n\\u2B1C 13     import logger from 'Shared/logger';\\n\\u2B1C 14     \\n\\uD83D\\uDFE9 15     export async function upgradeFiles(unitId: string, all: boolean) {\\n\\u2B1C 16       if (!unitId && !all) {\\n\\u2B1C 17         pprint.err(pprint.styles.error('Please enter the Swimm file Id you would like to upgrade or use -a to upgrade all Swimm files in this repo.'));\\n\\u2B1C 18         return config.ERROR_RETURN_CODE;\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"before starting the upgrade we verify that the units are applicable. this is important because we don't want to save an outdated version of the files.\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 33       if (all) {\\n\\u2B1C 34         // verify all units are applicable\\n\\u2B1C 35         pprint.out(pprint.styles.info(`Verifying units before attempting to upgrade...\\\\n`));\\n\\uD83D\\uDFE9 36         const verifyResult = await cliUtils.verifyUnitsInRepo({ unitId: unitId, isAutofixable: true });\\n\\u2B1C 37         if (!verifyResult) {\\n\\u2B1C 38           pprint.err(pprint.styles.error('Some of the units are not up to date, please update or sync them before running upgrade-files.'));\\n\\u2B1C 39           return config.ERROR_RETURN_CODE;\\n\")), mdx(\"br\", null)), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"The upgrade\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"After passing all the validation steps, we preform the update for the  a specific unit (if the command was provided with a unit ID) or to all the units in the repo if provided with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-a\"), \" flag. \"), mdx(\"br\", null), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 58       for (const unitId of unitsToUpgrade) {\\n\\u2B1C 59         try {\\n\\u2B1C 60           spinner.start(` * ${unitId}`);\\n\\uD83D\\uDFE9 61           await upgradeUnitFile(unitId);\\n\\u2B1C 62           spinner.succeed();\\n\\u2B1C 63         } catch (err) {\\n\\u2B1C 64           logger.error(`Upgrading Swimm file ${unitId} failed. Details: ${err.toString()} `, { service: 'cli-upgrade-files' });\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"autosync\"), \" each unit - the autosync call returns us the unit at it's latest format. We needed to call it to make sure that the snippets are aligned with the latest state of the repo.\\nAt this point we know the snippets are applicable, and autosync just fix the lines numbers and contexts.\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 73     \\n\\u2B1C 74     async function upgradeUnitFile(unitId) {\\n\\u2B1C 75       const swmFilePath = utils.pathInSwmFolder(`${unitId}${config.SWM_FILE_EXTENSION}`);\\n\\uD83D\\uDFE9 76       // autoFixUnit load and convert unit to the new file structure\\n\\uD83D\\uDFE9 77       // we autosyncing the applicable unit (patch applicable) to make sure the lines and context are correct on save\\n\\uD83D\\uDFE9 78       const autosyncResult = await autoFixUnit(unitId);\\n\\u2B1C 79       if (!autosyncResult.autoFixSuccess) {\\n\\u2B1C 80         throw new Error(`There was an issue while trying to autosync Swimm file: ${unitId}`);\\n\\u2B1C 81       }\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"After a successful autosync we can update the files blob_sha (meta) with the current (HEAD) SHAs.\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/cli/commands/upgrade-files.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 86     \\n\\u2B1C 87       const convertedAndAutosyncedUnit = autosyncResult.autoFixedSwmFile;\\n\\u2B1C 88       try {\\n\\uD83D\\uDFE9 89         // update file blobs - current HEAD\\n\\uD83D\\uDFE9 90         updateBlobShas({ swmFile: convertedAndAutosyncedUnit, meta: meta });\\n\\u2B1C 91     \\n\\u2B1C 92         convertedAndAutosyncedUnit.meta = { ...meta };\\n\\u2B1C 93     \\n\")), mdx(\"br\", null)), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Load And Convert\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"In addition to updating the snippets, line numbers and blobs sha, one of the major thing that is happening is converting old version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\"), \" files to the latest structure.\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loadAndConvertSwmFile\"), \" method is called as part of the autosync unit call but it being called when ever we loading a swm file (in the cli and in the app).\"), mdx(\"br\", null), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/swimmagic/autofix.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 28      * @return {Promise<boolean>} - Was the unit fixing process successful\\n\\u2B1C 29      */\\n\\u2B1C 30     export async function autoFixUnit(unitId: string): Promise<{ autoFixSuccess: boolean; autoFixedSwmFile?: SwmFile }> {\\n\\uD83D\\uDFE9 31       const swmFile = await loadAndConvertSwmFile(pathInSwmFolder(`${unitId}${config.SWM_FILE_EXTENSION}`));\\n\\u2B1C 32     \\n\\u2B1C 33       try {\\n\\u2B1C 34         const autoFixResult = autoFixUnitMainFlow({ destCommit: 'HEAD', unit: swmFile });\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We first loading the swm JSON and then do the conversion to the latest structure \"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/shared/common.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 109      return decodedSwmFileContent;\\n\\u2B1C 110    }\\n\\u2B1C 111    \\n\\uD83D\\uDFE9 112    export async function loadAndConvertSwmFile(swmPath: string): Promise<SwmFile> {\\n\\uD83D\\uDFE9 113      const loadedSwm = await utils.loadSwmFile(swmPath);\\n\\uD83D\\uDFE9 114      return convertSWMStructure(loadedSwm);\\n\\uD83D\\uDFE9 115    }\\n\\u2B1C 116    \\n\\u2B1C 117    /**\\n\\u2B1C 118     * Convert an old dumb-doc into the new SwmFile structure.\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The first part of the convert is update very old file to version 1.0.4.\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/shared/common.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 156    }\\n\\u2B1C 157    \\n\\u2B1C 158    // For backward compatibility, if needed - convert diff from an old SWM file without swimmPatch to dynamicSwimmPatch structure.\\n\\uD83D\\uDFE9 159    export function convertSWMStructure(unitFile) {\\n\\uD83D\\uDFE9 160      let convertedSWMFile = { ...unitFile };\\n\\uD83D\\uDFE9 161      if (utils.assertFileVersion({ fileVersion: unitFile.file_version, operator: '<', versionToCompare: '2.0.0' })) {\\n\\uD83D\\uDFE9 162        // Up to 1.0.4 inclusive - the conversion process relied on this to happen\\n\\uD83D\\uDFE9 163        // There is no 1.0.5 - after 1.0.4 we had 2.0.0\\n\\uD83D\\uDFE9 164        convertedSWMFile = preV2prepareLoadedSwmFile(unitFile);\\n\\uD83D\\uDFE9 165    \\n\\uD83D\\uDFE9 166        if (utils.assertFileVersion({ fileVersion: unitFile.file_version, operator: '<', versionToCompare: '1.0.3' })) {\\n\\uD83D\\uDFE9 167          convertedSWMFile = upgradeSWMFileStructureFrom102OrBelowTo104(convertedSWMFile);\\n\\uD83D\\uDFE9 168        } else {\\n\\uD83D\\uDFE9 169          if (utils.assertFileVersion({ fileVersion: unitFile.file_version, operator: '<', versionToCompare: '1.0.4' })) {\\n\\uD83D\\uDFE9 170            convertedSWMFile.hunksOrder = generateHunksOrderStaticSwimmPatchSwmFile104(convertedSWMFile.swimmPatch);\\n\\uD83D\\uDFE9 171          }\\n\\uD83D\\uDFE9 172        }\\n\\u2B1C 173        // Now convert from 1.0.4 to 2.0.0\\n\\u2B1C 174        try {\\n\\u2B1C 175          convertedSWMFile = upgradeSWMFileFrom104to200(convertedSWMFile, unitFile.file_version);\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"And then converting to the latest version.\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/shared/common.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 172        }\\n\\u2B1C 173        // Now convert from 1.0.4 to 2.0.0\\n\\u2B1C 174        try {\\n\\uD83D\\uDFE9 175          convertedSWMFile = upgradeSWMFileFrom104to200(convertedSWMFile, unitFile.file_version);\\n\\u2B1C 176        } catch (err) {\\n\\u2B1C 177          throw new Error(`could not convert unit to file vesion 2.0.0, Details: ${err.toString()}`);\\n\\u2B1C 178        }\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Here are few of the changes to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"set up a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"task\"), \" entry for unit with hands-on task\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/shared/common.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 196        task: {},\\n\\u2B1C 197      };\\n\\u2B1C 198    \\n\\uD83D\\uDFE9 199      // populate task fields\\n\\uD83D\\uDFE9 200      const task: SwmTask = {\\n\\uD83D\\uDFE9 201        dod: swmFileInVersion104.dod,\\n\\uD83D\\uDFE9 202        hints: swmFileInVersion104.hints,\\n\\uD83D\\uDFE9 203        tests: swmFileInVersion104.tests,\\n\\uD83D\\uDFE9 204      };\\n\\uD83D\\uDFE9 205      if (swmFileInVersion104.cr) {\\n\\uD83D\\uDFE9 206        task.crActions = swmFileInVersion104.cr;\\n\\uD83D\\uDFE9 207      }\\n\\uD83D\\uDFE9 208      newStructure.task = task;\\n\\u2B1C 209    \\n\\u2B1C 210      // populate file_blobs\\n\\u2B1C 211      for (const file of Object.keys(swmFileInVersion104.swimmPatch)) {\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"move from swimmPatch structure - where hunks where under the files name and the order was saved separately.\\nto an array of content with more readable structure where the order is clear and allow a mix of snippets and text blocks (and more).\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 src/shared/common.ts  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"\\u2B1C 211      for (const file of Object.keys(swmFileInVersion104.swimmPatch)) {\\n\\u2B1C 212        newStructure.meta.file_blobs[file] = '';\\n\\u2B1C 213      }\\n\\uD83D\\uDFE9 214      // populate content\\n\\uD83D\\uDFE9 215      // first cell is a text that include the intro\\n\\uD83D\\uDFE9 216      newStructure.content.push({ type: 'text', text: swmFileInVersion104.description });\\n\\uD83D\\uDFE9 217      // addind snippets based on the order\\n\\uD83D\\uDFE9 218    \\n\\uD83D\\uDFE9 219      for (const hunkOrderId of swmFileInVersion104.hunksOrder) {\\n\\uD83D\\uDFE9 220        const hunkOrderIdSplitIndex = hunkOrderId.lastIndexOf('_');\\n\\uD83D\\uDFE9 221        const hunkFile = hunkOrderId.substring(0, hunkOrderIdSplitIndex);\\n\\uD83D\\uDFE9 222        const hunkIndexInFile = hunkOrderId.substring(hunkOrderIdSplitIndex + 1, hunkOrderId.length);\\n\\uD83D\\uDFE9 223        const swimmFilePatch = swmFileInVersion104.swimmPatch[hunkFile];\\n\\uD83D\\uDFE9 224        const patchType = dynamicFileDiffTypeToSwmFilePatchType(swimmFilePatch.diffType);\\n\\uD83D\\uDFE9 225        let snippetCell = {};\\n\\uD83D\\uDFE9 226        if (utils.assertFileVersion({ fileVersion: orignalFileVersion, operator: '<', versionToCompare: '1.0.3' })) {\\n\\uD83D\\uDFE9 227          const hunkToAdd = swimmFilePatch.hunkContainers[hunkIndexInFile];\\n\\uD83D\\uDFE9 228          snippetCell = dynamicHunkContainerToSwmCellSnippet(hunkToAdd, hunkFile, patchType);\\n\\uD83D\\uDFE9 229          if (hunkToAdd.swimmHunkMetadata && hunkToAdd.swimmHunkMetadata.hunkComments) {\\n\\uD83D\\uDFE9 230            snippetCell['comments'] = hunkToAdd.swimmHunkMetadata.hunkComments;\\n\\uD83D\\uDFE9 231          }\\n\\uD83D\\uDFE9 232        } else {\\n\\uD83D\\uDFE9 233          // version 1.0.4\\n\\uD83D\\uDFE9 234          snippetCell = ConvertOldHunkToNewHunkFormat({ hunk: swimmFilePatch.hunks[hunkIndexInFile], fileName: hunkFile, patchType: patchType });\\n\\uD83D\\uDFE9 235        }\\n\\uD83D\\uDFE9 236    \\n\\uD83D\\uDFE9 237        newStructure.content.push(snippetCell);\\n\\u2B1C 238      }\\n\\u2B1C 239    \\n\\u2B1C 240      // add summary to content\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"To summarize this unit, it is important to know how we support older versions of files and understand the flow that happens when we load a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"swm\"), \" file, and how we can leverage the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"upgrade-files\"), \" command to update the files and save a bit on performance - especially autosyncing the snippets and updating the blobs SHA.\"), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This file was generated by Swimm. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://swimm.io/link?l=c3dpbW0lM0ElMkYlMkZyZXBvcyUyRnZlZXp2eEN1enBQclJMTFhXRDJFJTJGZG9jcyUyRjU1bUZGcHMzS1d2YUxHYnpQdDlN\"\n  }), \"Click here to view it in the app\"), \". Timestamp: 2021-04-20T19:12:42.663Z\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#files-used","title":"Files Used:"}]},{"url":"#the-upgrade","title":"The upgrade"},{"url":"#load-and-convert","title":"Load And Convert"}]},"timeToRead":2,"parent":{"__typename":"File","relativePath":"55mFFps3KWvaLGbzPt9M.md","fields":null},"frontmatter":{"metaTitle":null,"showMetadata":null,"editable":false,"showPreviousNext":null,"showToc":null}},"gitBranch":{"name":"master"},"gitCommit":{"hash":"0cb17677e25377d6041a73fa8033496a1bb1ce03","date":"2021-04-21 03:46"}},"pageContext":{"id":"2f2ae413-aa4a-5ac3-8344-26df686f036b"}},"staticQueryHashes":["12478684","12478684","2882937274","2882937274","353167761","353167761","3812332637","3812332637"]}