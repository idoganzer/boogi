{"componentChunkName":"component---src-templates-docs-js","path":"/HF27efU3ISWcyDFYInzX","result":{"data":{"site":{"siteMetadata":{"title":"My BooGi App","docsLocation":"","docsLocationType":"","editable":true}},"mdx":{"fields":{"id":"15061832-26fe-5a93-a494-2fccd0ea58af","title":"Firestore Whitelisted Fields","slug":"/HF27efU3ISWcyDFYInzX"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Firestore Whitelisted Fields\",\n  \"editable\": false\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"div\", {\n    align: \"center\",\n    style: {\n      \"backgroundColor\": \"#e5ecff\"\n    }\n  }, \"    \", mdx(\"br\", null), \"    \", mdx(\"div\", null, \"DOC\"), \"    \", mdx(\"h1\", null, \"Firestore Whitelisted Fields\"), \"    \", mdx(\"br\", null), \"  \"), mdx(\"section\", null, mdx(\"h3\", {\n    parentName: \"section\"\n  }, \"Files Used:\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"\\uD83D\\uDCC4 cloud/firestore.rules\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"\\uD83D\\uDCC4 cloud/firestore_rules.spec.js\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"When updating a document in Firestore we want to make sure we allow to update only relevant and/or specific fields\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"To do so, we're using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://swimm.io/link?l=c3dpbW0lM0ElMkYlMkZ3b3Jrc3BhY2VzJTJGYVJ2TXFjMHlXQVZjSmxMTjk0NEQlMkZyZXBvcyUyRnZlZXp2eEN1enBQclJMTFhXRDJFJTJGdW5pdHMlMkZQRFVlRGtoS1NGQWRRS1VkTUxUag==\"\n  }), \"Firestore security rules\"), \" in order to make sure DB access is secure\"), mdx(\"br\", null)), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Whitelist fields example - repository\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validateAllowedRepositoryUpdateFields()\"), \" and validateAllowedRepositoryCreateFields() to our allow create and update conditions\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 cloud/firestore.rules  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rules\"\n  }), \"\\u2B1C 123    \\n\\u2B1C 124        match /repositories/{repository} {\\n\\uD83D\\uDFE9 125          allow create: if validateAllowedRepositoryCreateFields();\\n\\uD83D\\uDFE9 126          allow update: if isUserLifeguard(repository) && validateAllowedRepositoryUpdateFields();\\n\\u2B1C 127          allow read: if true;  // Allow reading the fields of the repo document - these are public\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Checking our requests has only valid whitelisted keys for creation/update\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"The request will fail if it has non-whitelisted fields in its data\"), mdx(\"br\", null), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 cloud/firestore.rules  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rules\"\n  }), \"\\u2B1C 196          function isSwimmCreator(repoId, swimmId) {\\n\\u2B1C 197            return get(/databases/$(database)/documents/repositories/$(repoId)/swimms/$(swimmId)).data.creator == request.auth.uid;\\n\\u2B1C 198          }\\n\\uD83D\\uDFE9 199          function validateAllowedRepositoryCreateFields(){\\n\\uD83D\\uDFE9 200            // Make sure the request fields changes only allowed fields and nothing else\\n\\uD83D\\uDFE9 201            return request.resource.data.keys().toSet().hasOnly([\\\"name\\\", \\\"description\\\", \\\"logo\\\", \\\"creator\\\", \\\"owner\\\", \\\"created\\\", \\\"modified\\\", \\\"modifier\\\", \\\"modifier_name\\\", \\\"url\\\", \\\"provider\\\", \\\"integrations\\\", \\\"counter_swimms\\\", \\\"counter_playlists\\\", \\\"counter_swimmers\\\", \\\"counter_lifeguards\\\"]);\\n\\uD83D\\uDFE9 202          }\\n\\u2B1C 203          function validateAllowedRepositoryUpdateFields(){\\n\\u2B1C 204            // Make sure the request fields changes only allowed fields and nothing else\\n\\u2B1C 205            return request.resource.data.diff(resource.data).affectedKeys().hasOnly([\\\"id\\\", \\\"name\\\", \\\"description\\\", \\\"logo\\\", \\\"modified\\\", \\\"modifier\\\", \\\"modifier_name\\\", \\\"integrations\\\"]);\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Notice\"), \" - We check \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"affectedKeys\"), \" (document fields changed by the request) has only whitelisted keys\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"We're adding to whitelist only the fields that we're able to update via the UI\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 cloud/firestore.rules  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rules\"\n  }), \"\\u2B1C 200            // Make sure the request fields changes only allowed fields and nothing else\\n\\u2B1C 201            return request.resource.data.keys().toSet().hasOnly([\\\"name\\\", \\\"description\\\", \\\"logo\\\", \\\"creator\\\", \\\"owner\\\", \\\"created\\\", \\\"modified\\\", \\\"modifier\\\", \\\"modifier_name\\\", \\\"url\\\", \\\"provider\\\", \\\"integrations\\\", \\\"counter_swimms\\\", \\\"counter_playlists\\\", \\\"counter_swimmers\\\", \\\"counter_lifeguards\\\"]);\\n\\u2B1C 202          }\\n\\uD83D\\uDFE9 203          function validateAllowedRepositoryUpdateFields(){\\n\\uD83D\\uDFE9 204            // Make sure the request fields changes only allowed fields and nothing else\\n\\uD83D\\uDFE9 205            return request.resource.data.diff(resource.data).affectedKeys().hasOnly([\\\"id\\\", \\\"name\\\", \\\"description\\\", \\\"logo\\\", \\\"modified\\\", \\\"modifier\\\", \\\"modifier_name\\\", \\\"integrations\\\"]);\\n\\uD83D\\uDFE9 206          }\\n\\u2B1C 207          function canDeleteSwimm(repoId, swimmId) {\\n\\u2B1C 208            return isUserLifeguard(repoId) || (isUserInPrivateRepo(repoId) && isSwimmCreator(repoId, swimmId))\\n\\u2B1C 209          }\\n\")), mdx(\"br\", null)), mdx(\"section\", null, mdx(\"h2\", {\n    parentName: \"section\"\n  }, \"Whitelist fields tests\"), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Now we test our create/update rules:\"), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Make sure a user can create a new repo only when all fields are whitelisted fields\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 cloud/firestore_rules.spec.js  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\u2B1C 670          const repoDocument = db.collection('repositories').doc('test');\\n\\u2B1C 671          await firebase.assertFails(repoDocument.update({ name: 'name-can-be-edited', url: 'https://swimm.io/route/to/url-failure' }));\\n\\u2B1C 672        });\\n\\uD83D\\uDFE9 673        it('a user can create a new repo with valid whitelisted data', async () => {\\n\\uD83D\\uDFE9 674          const db = await dbSetup({ uid: noLifeguardUid }, mockData);\\n\\uD83D\\uDFE9 675          const repositories = db.collection('repositories');\\n\\uD83D\\uDFE9 676          await firebase.assertSucceeds(\\n\\uD83D\\uDFE9 677            repositories.add({\\n\\uD83D\\uDFE9 678              counter_lifeguards: 0,\\n\\uD83D\\uDFE9 679              counter_playlists: 0,\\n\\uD83D\\uDFE9 680              counter_swimmers: 0,\\n\\uD83D\\uDFE9 681              counter_swimms: 0,\\n\\uD83D\\uDFE9 682              creator: 'creatorId',\\n\\uD83D\\uDFE9 683              name: 'new added test respository',\\n\\uD83D\\uDFE9 684              owner: 'owner',\\n\\uD83D\\uDFE9 685              provider: 'github',\\n\\uD83D\\uDFE9 686              url: 'https://github.com/kpdecker/jsdiff.git',\\n\\uD83D\\uDFE9 687            })\\n\\uD83D\\uDFE9 688          );\\n\\uD83D\\uDFE9 689        });\\n\\uD83D\\uDFE9 690        it('a user cannot create a new repo with non-whitelisted data', async () => {\\n\\uD83D\\uDFE9 691          const db = await dbSetup({ uid: noLifeguardUid }, mockData);\\n\\uD83D\\uDFE9 692          const repositories = db.collection('repositories');\\n\\uD83D\\uDFE9 693          await firebase.assertFails(repositories.add({ name: 'name-can-be-edited', something: 'not-whitelisted-data' }));\\n\\uD83D\\uDFE9 694        });\\n\\u2B1C 695        it(\\\"a swimmer cannot update the repo's document\\\", async () => {\\n\\u2B1C 696          const db = await dbSetup({ uid: noLifeguardUid }, mockData);\\n\\u2B1C 697          const repoDocument = db.collection('repositories').doc('test');\\n\")), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"Make sure a lifeguard that is allowed to update a repository cannot edit not whitelisted fields\"), mdx(\"div\", {\n    style: {\n      \"background\": \"#e5ecff\",\n      \"padding\": \"10px 10px 10px 10px\",\n      \"borderBottom\": \"1px solid #c1c7d0\",\n      \"borderRadius\": \"4px\"\n    }\n  }, \"    \\uD83D\\uDCC4 cloud/firestore_rules.spec.js  \"), mdx(\"pre\", {\n    parentName: \"section\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\u2B1C 665            })\\n\\u2B1C 666          );\\n\\u2B1C 667        });\\n\\uD83D\\uDFE9 668        it(\\\"a lifeguard cannot update repo's non-whitelisted fields\\\", async () => {\\n\\uD83D\\uDFE9 669          const db = await dbSetup({ uid: lifeguardUid }, mockData);\\n\\uD83D\\uDFE9 670          const repoDocument = db.collection('repositories').doc('test');\\n\\uD83D\\uDFE9 671          await firebase.assertFails(repoDocument.update({ name: 'name-can-be-edited', url: 'https://swimm.io/route/to/url-failure' }));\\n\\uD83D\\uDFE9 672        });\\n\\u2B1C 673        it('a user can create a new repo with valid whitelisted data', async () => {\\n\\u2B1C 674          const db = await dbSetup({ uid: noLifeguardUid }, mockData);\\n\\u2B1C 675          const repositories = db.collection('repositories');\\n\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"br\", null), mdx(\"p\", {\n    parentName: \"section\"\n  }, \"This file was generated by Swimm. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://swimm.io/link?l=c3dpbW0lM0ElMkYlMkZyZXBvcyUyRnZlZXp2eEN1enBQclJMTFhXRDJFJTJGZG9jcyUyRkhGMjdlZlUzSVNXY3lERllJbnpY\"\n  }), \"Click here to view it in the app\"), \". Timestamp: 2021-04-20T19:12:42.759Z\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#files-used","title":"Files Used:"}]},{"url":"#whitelist-fields-example---repository","title":"Whitelist fields example - repository"},{"url":"#whitelist-fields-tests","title":"Whitelist fields tests"}]},"timeToRead":1,"parent":{"__typename":"File","relativePath":"HF27efU3ISWcyDFYInzX.md","fields":null},"frontmatter":{"metaTitle":null,"showMetadata":null,"editable":false,"showPreviousNext":null,"showToc":null}},"gitBranch":{"name":"master"},"gitCommit":{"hash":"0cb17677e25377d6041a73fa8033496a1bb1ce03","date":"2021-04-21 03:46"}},"pageContext":{"id":"15061832-26fe-5a93-a494-2fccd0ea58af"}},"staticQueryHashes":["12478684","12478684","2882937274","2882937274","353167761","353167761","3812332637","3812332637"]}